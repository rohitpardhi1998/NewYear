select name,open_mode,database_role from v$database;

**********************************************

INACTIVE SESSIONS

select count(s.status) INACTIVE_SESSIONS
from gv$session s, v$process p
where
p.addr=s.paddr and
s.status='INACTIVE';

\\\

Select count(*) From V$session where status='ACTIVE'and USERNAME='LTO2';  

select count(*) From V$session where status='INACTIVE'and USERNAME='SL1';  

select count(*) From V$session where status='INACTIVE'and username='SL1';  

select count(*) From V$session where status='ACTIVE'and username='SL1';                // to check session for particular user 


 SELECT USERNAME FROM V$SESSION;   /// to check session for all user in database 


select count(*),USERNAME,status From V$session where status='ACTIVE';and USERNAME='SL1';
set echo off
set linesize 95
set head on
set feedback on
col sid head "Sid" form 9999 trunc
col serial# form 99999 trunc head "Ser#"
col username form a8 trunc
col osuser form a7 trunc
col machine form a20 trunc head "Client|Machine"
col program form a15 trunc head "Client|Program"
col login form a11
col "last call" form 9999999 trunc head "Last Call|In Secs"
col status form a6 trunc
select sid,serial#,substr(username,1,10) username,substr(osuser,1,10) osuser,
substr(program||module,1,15) program,substr(machine,1,22) machine,
to_char(logon_time,'ddMon hh24:mi') login,
last_call_et "last call",status
from v$session where status='ACTIVE'                                                                                 .. to find activer session in the databse 
order by 1
/
***********************************************

ACTIVE SESSIONS

select count(s.status) ACTIVE_SESSIONS
from gv$session s, v$process p
where
p.addr=s.paddr and
s.status='ACTIVE';

***********************************************

WAIT EVENTS

SET LINESIZE 200
SET PAGESIZE 1000

COLUMN username FORMAT A20
COLUMN event FORMAT A30
COLUMN wait_class FORMAT A15

SELECT NVL(s.username, '(oracle)') AS username,
       s.sid,
       s.serial#,
       sw.event,
       sw.wait_class,
       sw.wait_time,
       sw.seconds_in_wait,
       sw.state
FROM   v$session_wait sw,
       v$session s
WHERE  s.sid = sw.sid
ORDER BY sw.seconds_in_wait DESC;

***********************************************

DEAD LOCKS

select
   c.owner,
   c.object_name,
   c.object_type,
   b.sid,
   b.serial#,
   b.status,
   b.osuser,
   b.machine
from
v$locked_object a ,
   v$session b,
   dba_objects c
where
   b.sid = a.session_id
and
   a.object_id = c.object_id;

***********************************************

BLOCKING LOCKS

 select
   blocking_session,
   status,
   sid,
   serial#,
   wait_class,
   seconds_in_wait
from
   v$session
where
   blocking_session is not NULL
order by
   blocking_session;



SELECT
   s.blocking_session, 
   s.sid, 
   s.serial#, 
   s.seconds_in_wait
FROM
   gv$session s
WHERE
   blocking_session IS NOT NULL;


in tata steel
==================
SELECT s1.username || '@' || s1.machine
|| ' ( SID=' || s1.sid || ' )  is blocking '
|| s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status
FROM v$lock l1, v$session s1, v$lock l2, v$session s2
 WHERE s1.sid=l1.sid AND s2.sid=l2.sid
AND l1.BLOCK=1 AND l2.request > 0
AND l1.id1 = l2.id1
  AND l1.id2 = l2.id2;

> select sid,serial# from v$session where sid=89;

ALTER SYSTEM KILL SESSION '89,7767' IMMEDIATE; --- to kill sid 


SELECT    'ALTER SYSTEM KILL SESSION '''                  --- to get command to kill in one time
      || s.sid
      || ','
      || s.serial#
      || ''' IMMEDIATE;'
         AS ddl
 FROM v$session s
WHERE s.blocking_session IS NOT NULL ;


***********************************************

Select SID, Serial#, UserName, Status,SchemaName ,Logon_Time from V$Session Where Status='ACTIVE' AND UserName IS NOT NULL;



Select SID, Serial#, UserName, Status,SchemaName ,Logon_Time from V$Session Where Status='ACTIVE' AND USERNAME='';
LONG RUNNING JOBS

COLUMN opname FORMAT A20
COLUMN target_desc FORMAT A20
COLUMN units FORMAT A10

SELECT
   opname,
   target_desc,
   sofar,
   totalwork,
   time_remaining,
    units
FROM  
   v$session_longops;
***********************************************

LATCHES

 SELECT n.name, SUM(w.p3) Sleeps
  FROM V$SESSION_WAIT w, V$LATCHNAME n
 WHERE w.event = 'latch free'
   AND w.p2 = n.latch#
 GROUP BY n.name;

************************************************

   set verify off
column PctTotSPMem for all
select ksmchcls "ChnkClass",
    sum(ksmchsiz) "SumChunkTypeMem",
    Max(ksmchsiz) "LargstChkofThisTyp",
    count(1) "NumOfChksThisType",
    round((sum(ksmchsiz)/tot_sp_mem.totspmem),2)*100||'%' "PctTotSPMem"
from x$ksmsp,
    (select sum(ksmchsiz) TotSPMem from x$ksmsp) tot_sp_mem
group by ksmchcls, tot_sp_mem.TotSPMem
order by sum(ksmchsiz);

**************************************************
LOG SYNC  and LOG SEQ NNUMBER

SELECT ARCH.THREAD# "Thread", ARCH.SEQUENCE# "Last Sequence Received", APPL.SEQUENCE# "Last Sequence Applied", (ARCH.SEQUENCE# - APPL.SEQUENCE#) "Difference"
FROM
(SELECT THREAD# ,SEQUENCE# FROM V$ARCHIVED_LOG WHERE (THREAD#,FIRST_TIME ) IN (SELECT THREAD#,MAX(FIRST_TIME) FROM V$ARCHIVED_LOG GROUP BY THREAD#)) ARCH,
(SELECT THREAD# ,SEQUENCE# FROM V$LOG_HISTORY WHERE (THREAD#,FIRST_TIME ) IN (SELECT THREAD#,MAX(FIRST_TIME) FROM V$LOG_HISTORY GROUP BY THREAD#)) APPL
WHERE
ARCH.THREAD# = APPL.THREAD#
;

***************************************************
ASM logs 


SET LINESIZE  145
SET PAGESIZE  9999
SET VERIFY    off

COLUMN group_name             FORMAT a20           HEAD 'Disk Group|Name'
COLUMN sector_size            FORMAT 99,999        HEAD 'Sector|Size'
COLUMN block_size             FORMAT 99,999        HEAD 'Block|Size'
COLUMN allocation_unit_size   FORMAT 999,999,999   HEAD 'Allocation|Unit Size'
COLUMN state                  FORMAT a11           HEAD 'State'
COLUMN type                   FORMAT a6            HEAD 'Type'
COLUMN total_mb               FORMAT 999,999,999   HEAD 'Total Size (MB)'
COLUMN used_mb                FORMAT 999,999,999   HEAD 'Used Size (MB)'
COLUMN pct_used               FORMAT 999.99        HEAD 'Pct. Used'

break on report on disk_group_name skip 1

compute sum label "Grand Total: " of total_mb used_mb on report

SELECT
    name                                     group_name
  , sector_size                              sector_size
  , block_size                               block_size
  , allocation_unit_size                     allocation_unit_size
  , state                                    state
  , type                                     type
  , total_mb                                 total_mb
  , (total_mb - free_mb)                     used_mb
  , ROUND((1- (free_mb / total_mb))*100, 2)  pct_used
FROM
    v$asm_diskgroup
ORDER BY
    name ;
******************************************************
DATABASE BACKUP (172.24.50.54)



	col STATUS format a9
	col hrs format 999.99
	select SESSION_KEY, INPUT_TYPE, STATUS,
	to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
	to_char(END_TIME,'mm/dd/yy hh24:mi') end_time,
	elapsed_seconds/3600 hrs
	from V$RMAN_BACKUP_JOB_DETAILS
	order by session_key;

=============================================================

set echo off
set linesize 132
set verify off
set feedback off
set serveroutput on;
declare
     SID number                := 0 ;
     SERIAL number             := 0 ;
     username varchar(20)      := '';
     Status varchar(8)         := '';
     machine  varchar(10)      := '';
     terminal   varchar(25)    := '';
     program   varchar(30)     := '';
     Module varchar(30)        := '';
     Action varchar(20)        := '';
     sql_hash_value  number    := 0 ;
     logontime varchar(30)     := '';
     last_call_et number       := 0 ;
     proc number               := 0 ;
     spid number               := 0 ;
     event varchar(30)         := '';
     state varchar(30)         := '';
     sql_text varchar(2000)    := '';
cursor cur1 is
select  a.sid  sid,
     a.serial#  serial,
     a.username username,
     a.status status ,
     a.machine machine,
     a.terminal terminal,
     a.program program,
     a.module module,
     a.action action,
     a.sql_hash_value sql_hash_value,
     to_char(a.logon_time,'DD-Mon-YYYY HH:mi:SS') logontime,
     a.last_call_et last_call_et,
     a.process proc,
     b.spid  spid,
     sw.event event,
     sw.state  state
from   gv$session a, gv$process b,  gv$session_wait  sw
where  a.paddr=b.addr and a.inst_id=b.inst_id
     and a.sid='&1'
     and a.inst_id=sw.inst_id
     and a.sid=sw.sid;
begin
  DBMS_OUTPUT.PUT_LINE('-----------------------------------------------------------------');
  DBMS_OUTPUT.PUT_LINE(' Database session detail for the shadow process ');
  DBMS_OUTPUT.PUT_LINE('-----------------------------------------------------------------');
for m in cur1
loop
DBMS_OUTPUT.ENABLE(50000);
    DBMS_OUTPUT.PUT_LINE('  ');
    DBMS_OUTPUT.PUT_LINE( 'SID............ : ' || m.sid  );
    DBMS_OUTPUT.PUT_LINE('SERIAL#........ : ' || m.serial   );
    DBMS_OUTPUT.PUT_LINE('USERNAME....... : ' || m.username   );
    DBMS_OUTPUT.PUT_LINE('STATUS......... : ' || m.status     );
    DBMS_OUTPUT.PUT_LINE( 'Machine........ : ' || m.machine );
    DBMS_OUTPUT.PUT_LINE( 'Terminal....... : ' || m.terminal);
    DBMS_OUTPUT.PUT_LINE( 'Program........ : ' || m.program  );
    DBMS_OUTPUT.PUT_LINE('Module......... : ' || m.module  );
    DBMS_OUTPUT.PUT_LINE( 'Action......... : ' || m.action  );
    DBMS_OUTPUT.PUT_LINE('SQL Hash Value. : ' || m.sql_hash_value );
    DBMS_OUTPUT.PUT_LINE( 'Logon Time..... : ' || m.logontime );
    DBMS_OUTPUT.PUT_LINE(  'Last Call Et... : ' || m.last_call_et  );
    DBMS_OUTPUT.PUT_LINE( 'Process ID..... : ' || m.proc );
    DBMS_OUTPUT.PUT_LINE(  'SPID........... : ' || m.spid );
    DBMS_OUTPUT.PUT_LINE('Session Waiting for event:'||m.event );
    DBMS_OUTPUT.PUT_LINE('Session state ...........:'||m.state);
dbms_output.put_line('SQL_TEXT is..........:');
for rec in ( select sql_text from v$session s,v$sqltext v where
    s.sql_hash_value=v.hash_value and
    s.sql_address=v.address and s.sid=m.sid order by piece)
loop
dbms_output.put_line(rec.sql_text);
end loop;
    DBMS_OUTPUT.PUT_LINE('--------------------------------------------------------------------');
    DBMS_OUTPUT.PUT_LINE(' ');
end loop;
end;
/

================================================================================================================
To kill the blocking session
======================================


select 'alter system kill session ''' || sid || ',' || serial# || ',@'|| inst_id ||''';' from gv$session where sid=785;

=========================================================
To set alter swith in everby 15 min(redologswitch.sql)
==========
set time on
ALTER SYSTEM SWITCH LOGFILE;
select max(sequence#) from v$log_history;

crontab
=========
export ORACLE_SID=PUM92UAT
export ORACLE_BASE=/u01/app/oracle
export ORACLE_HOME=/u01/app/oracle/product/12.1.0/db_1
cd /home/oracle/scripts/
/u01/app/oracle/product/12.1.0/db_1/bin/sqlplus /nolog << EOF
connect /as sysdba

column dcol new_value SYSDATE noprint
select to_char(sysdate,'yyyymmdd') dcol from dual;
spool /home/oracle/log/redologswitch_&sysdate.log append;

@redologswitch.sql

spool off;

EXIT;
EOF

=================================================================FRA USAGE ===================================

set lines 200 pages 200
col name for a30
SELECT NAME,(SPACE_LIMIT / 1024 / 1024 / 1024) SPACE_LIMIT_GB,
((SPACE_LIMIT - SPACE_USED + SPACE_RECLAIMABLE) / 1024 / 1024 / 1024) AS SPACE_AVAILABLE_GB,
ROUND((SPACE_USED - SPACE_RECLAIMABLE) / SPACE_LIMIT * 100, 1) AS PERCENT_FULL
FROM V$RECOVERY_FILE_DEST;


